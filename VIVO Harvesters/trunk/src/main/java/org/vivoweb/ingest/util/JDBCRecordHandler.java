/*******************************************************************************
 * Copyright (c) 2010 Christopher Haines, Dale Scheppler, Nicholas Skaggs, Stephen V. Williams.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the new BSD license
 * which accompanies this distribution, and is available at
 * http://www.opensource.org/licenses/bsd-license.html
 * 
 * Contributors:
 *     Christopher Haines, Dale Scheppler, Nicholas Skaggs, Stephen V. Williams - initial API and implementation
 ******************************************************************************/
package org.vivoweb.ingest.util;

import java.io.IOException;
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.Iterator;
import java.util.Map;
import java.util.NoSuchElementException;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

/**
 * RecordHandler that stores data in a JDBC Database
 * @author Christopher Haines (hainesc@ctrip.ufl.edu)
 */
public class JDBCRecordHandler extends RecordHandler {
	
	/**
	 * Log4J Logger
	 */
	protected static Log log = LogFactory.getLog(JDBCRecordHandler.class);
	/**
	 * Database connection
	 */
	private Connection db;
	/**
	 * Database statement processor
	 */
	protected Statement cursor;
	/**
	 * Table name
	 */
	protected String table;
	/**
	 * All Tables must have this field as autoincrement primary key
	 */
	private static final String autoID = "UNIQUE_AUTOGENERATED_ID";
	/**
	 * All Tables must have this to store the identifier for each record
	 */
	protected static final String idField = "recordID";
	/**
	 * Field to store data in
	 */
	protected String dataField;
	
	/**
	 * Default Constructor
	 */
	protected JDBCRecordHandler() {
		//Nothing to do here
		//Used by config construction
		//Should only be used in conjunction with setParams()
	}
	
	/**
	 * Constructor
	 * @param jdbcDriverClass jdbc driver class
	 * @param connLine jdbc connection string
	 * @param username username to use for connection
	 * @param password password to use for connection
	 * @param tableName name of table to use
	 * @param dataFieldName name of field to store data in
	 * @throws IOException invalidly configured database
	 * 
	 */
	public JDBCRecordHandler(String jdbcDriverClass, String connLine, String username, String password, String tableName, String dataFieldName) throws IOException {
		initAll(jdbcDriverClass, connLine, username, password, tableName, dataFieldName);
	}
	
	/**
	 * Constructor
	 * @param jdbcDriverClass jdbc driver class
	 * @param connType jdbc connection type
	 * @param host host to connect to
	 * @param port port to connect on
	 * @param dbName name of database to connect to
	 * @param username username to use for connection
	 * @param password password to use for connection
	 * @param tableName name of table to use
	 * @param dataFieldName name of field to store data in
	 * @throws IOException invalidly configured database
	 */
	public JDBCRecordHandler(String jdbcDriverClass, String connType, String host, String port, String dbName, String username, String password, String tableName, String dataFieldName) throws IOException {
		this(jdbcDriverClass, buildConnLine(connType, host, port, dbName), username, password, tableName, dataFieldName);
	}
	
	@Override
	protected void finalize() throws Throwable {
		this.cursor.close();
		this.db.close();
	}
	
	/**
	 * Build a connection line using its components
	 * @param connType connection type
	 * @param host host name
	 * @param port port number
	 * @param dbName database name
	 * @return jdbc connection line
	 */
	private static String buildConnLine(String connType, String host, String port, String dbName) {
		return "jdbc:"+connType+"://"+host+":"+port+"/"+dbName;
	}
	
	/**
	 * Initialize variables
	 * @param jdbcDriverClass jdbc connection driver
	 * @param connLine jdbc connection line
	 * @param username username to connect with
	 * @param password password to connect with
	 * @param tableName tablename to write to
	 * @param dataFieldName field to store data in
	 * @throws IOException connection error
	 */
	private void initAll(String jdbcDriverClass, String connLine, String username, String password, String tableName, String dataFieldName) throws IOException {
		this.table = tableName;
		this.dataField = dataFieldName;
		try {
			Class.forName(jdbcDriverClass);
			this.db = DriverManager.getConnection(connLine, username, password);
			this.cursor = this.db.createStatement();
			if(!checkTableExists()){
				throw new IOException("Database Does Not Contain Table: "+this.table);
			}
			if(!checkTableConfigured()){
				throw new IOException("Table '"+this.table+"' Is Not Structured Correctly");
			}
		} catch(ClassNotFoundException e) {
			log.error("Unable to initialize DB Driver Class",e);
			throw new IOException("Unable to initialize DB Driver Class: "+e.getMessage());
		} catch(SQLException e) {
			log.error("Unable to connect to DB",e);
			throw new IOException("Unable to connect to DB: "+e.getMessage());
		}
	}
	
	/**
	 * Checks if a table is properly configured
	 * @return true if database is configured correctly, false otherwise
	 */
	private boolean checkTableConfigured() {
		boolean a = true;
		try {
			this.cursor.execute("select "+autoID+", "+idField+", "+this.dataField+" from "+this.table);
		} catch(SQLException e) {
			a = false;
		}
		return a;
	}
	
	/**
	 * Checks if the table exists
	 * @return true if table exists, false otherwise
	 */
	private boolean checkTableExists() {
		boolean a;
		try {
			// ANSI SQL way.  Works in PostgreSQL, MSSQL, MySQL
			this.cursor.execute("select case when exists((select * from information_schema.tables where table_name = '"+this.table+"')) then 1 else 0 end");
			a = this.cursor.getResultSet().getBoolean(1);
		} catch(SQLException e) {
			try {
				// Other RDBMS. Graceful degradation
				a = true;
				this.cursor.execute("select 1 from "+this.table+" where 1 = 0");
			} catch(SQLException e1) {
				a = false;
			}
		}
		return a;
	}
	
	@Override
	public void addRecord(Record rec, boolean overwrite) throws IOException {
		try {
			PreparedStatement ps = this.db.prepareStatement("insert into "+this.table+"("+idField+", "+this.dataField+") values (?, ?)");
			ps.setString(1, rec.getID());
			ps.setBytes(2, rec.getData().getBytes());
			ps.executeUpdate();
		} catch(SQLException e) {
			if(overwrite) {
				log.trace("Unable to add record: atempting to update existing record");
				try {
					PreparedStatement ps = this.db.prepareStatement("insert into "+this.table+"("+idField+", "+this.dataField+") values (?, ?)");
					ps.setString(1, rec.getID());
					ps.setBytes(2, rec.getData().getBytes());
					ps.executeUpdate();
				} catch(SQLException e2) {
					log.error("Unable to update record: "+rec.getID(),e2);
					throw new IOException("Unable to update record: "+rec.getID()+" - "+e2.getMessage());
				}
			} else {
				log.error("Unable to add record: "+rec.getID(),e);
				throw new IOException("Unable to add record: "+rec.getID()+" - "+e.getMessage());
			}
		}
	}
	
	@Override
	public void delRecord(String recID) throws IOException {
		try {
			this.cursor.execute("delete from "+this.table+" where "+idField+" = "+recID);
		} catch(SQLException e) {
			log.error("Unable to delete record: "+recID,e);
			throw new IOException("Unable to delete record: "+recID+" - "+e.getMessage());
		}
	}
	
	@Override
	public String getRecordData(String recID) throws IllegalArgumentException, IOException {
		try {
			return new String(this.cursor.executeQuery("select "+this.dataField+" from "+this.table+" where "+idField+" = "+recID).getBytes(1));
		} catch(SQLException e) {
			log.error("Unable to retrieve record: "+recID,e);
			throw new IOException("Unable to retrieve record: "+recID+" - "+e.getMessage());
		}
	}
	
	@Override
	public Iterator<Record> iterator() {
		JDBCRecordIterator ri = null;
		try {
			ri = new JDBCRecordIterator();
		} catch(SQLException e) {
			log.error("Unable to retrieve records",e);
		}
		return ri;
	}
	
	/**
	 * Iterator for JDBCRecordHandler
	 * @author Christopher Haines (hainesc@ctrip.ufl.edu)
	 */
	private class JDBCRecordIterator implements Iterator<Record> {
		/**
		 * The result set for records in a database
		 */
		ResultSet rs;
		
		/**
		 * Default Constructor
		 * @throws SQLException failed to read records
		 */
		protected JDBCRecordIterator() throws SQLException {
			this.rs = JDBCRecordHandler.this.cursor.executeQuery("select "+JDBCRecordHandler.idField+", "+JDBCRecordHandler.this.dataField+" from "+JDBCRecordHandler.this.table);
		}
		
		@Override
		public boolean hasNext() {
			try {
				return this.rs.next();
			} catch(SQLException e) {
				log.error("Unable to retrieve next record",e);
				return false;
			}
		}
		
		@Override
		public Record next() {
			try {
				return new Record(this.rs.getString(1),new String(this.rs.getBytes(2)));
			} catch(SQLException e) {
				throw new NoSuchElementException(e.getMessage());
			}
		}
		
		@Override
		public void remove() {
			throw new UnsupportedOperationException();
		}
	}
	
	@Override
	public void setParams(Map<String, String> params) throws IllegalArgumentException, IOException {
		String jdbcDriverClass = getParam(params,"jdbcDriverClass",true);
		String connLine = getParam(params,"connLine",false);
		String connType = getParam(params,"connType",false);
		String host = getParam(params,"host",false);
		String port = getParam(params,"port",false);
		String dbName = getParam(params,"dbName",false);
		String username = getParam(params,"username",true);
		String password = getParam(params,"password",true);
		String tableName = getParam(params,"tableName",true);
		String dataFieldName = getParam(params,"dataFieldName",true);
		boolean has4part = !(connType == null || host == null || port == null || dbName == null);
		if(connLine == null) {
			if(!has4part) {
				throw new IllegalArgumentException("Must have either connLine OR connType, host, port, and dbName");
			}
			initAll(jdbcDriverClass, buildConnLine(connType, host, port, dbName), username, password, tableName, dataFieldName);
		} else {
			if(has4part) {
				throw new IllegalArgumentException("Must have either connLine OR connType, host, port, and dbName, not both");
			}
			initAll(jdbcDriverClass, connLine, username, password, tableName, dataFieldName);
		}
	}
	
}
